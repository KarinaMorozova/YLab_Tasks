# Event Sourcing

Задача из предыдущего ДЗ. Должно быть реализована с разбиением на <b>Spring</b>
компоненты, а потом запуском как <b>spring</b> приложения. В качестве кандидатов на
оформление в виде компонентов - <b>DataSource</b>, <b>ConnectionFactory</b>, классы для отправки
сообщений, классы для получения сообщений, работы с БД.  

# Query Extender
Делая запрос к метаданным БД, необходимо узнать, какие колонки есть в 
конкретной таблице и, используя эти данные, написать корректный SQL запрос 
к этой таблице.  
Написать Spring Component, реализующий интерфейс   
    `public interface SQLQueryBuilder { `  
    `String queryForTable(String tableName); `  
    `List<String> getTables(); `  
    `} `  

   Метод <b>queryForTable</b> получает на вход имя таблицы и выполняет следующее:  
1. Проверяет, что данная таблица есть в Б.
2. Если таблицы нет - метод возвращает <b>null</b>.
3. Если таблица есть - получает список колонок.
4. На основании списка колонок составляется строка запроса вида  
   `“SELECT <col1>, <col2>, <col3> FROM <tablename>”`
5. Данная строка возвращается в качестве результата выполнения метода
   Пример: в БД есть таблица person c колонками <b>id, first_name, last_name, middle_name</b>.
   В результате метод должен вернуть строку:  
   `SELECT id, first_name, last_name, middle_name FROM person`  

Метод <b>getTables</b> возвращает в качестве результата список имен всех таблиц, которые
есть в БД.  

# Message Filter (18+) 

Необходимо написать приложение, которые бы осуществляло цензуру присылаемых
сообщений:
1. Приложение получает сообщение из очереди <b>input</b>.
2. Сообщение - это строка, в котором хранится предложение. 
3. Приложение проверяет каждое слово полученного предложение на предмет
   полного совпадения с одним из слов из списка (без учета регистра). Список
   находится после этого абзаца, но цвет букв - белый. Выделите белое
   пространство внизу для получения доступа к тексту.
4. Если слово совпадает с каким-либо словом из списка, то все буквы в в этом
   слове кроме первой и последней заменяются на *.
5. Если слово не совпадает, оно остается без изменений.
6. Модифицированное таким образом предложение отправляется в очередь <b>output</b>.

<b>Пример: </b>
Получено из очереди input: Fuck you, уважаемый!  
Отправлено в очередь output: F**k you, уважаемый!  

<b>Примечания по реализации</b>
1. Очереди <b>input</b> и <b>output</b> - очереди RabbitMQ.
2. Таблица со списком нецензурных слов должна создаваться при запуске
   приложения, но только в том случае, если такой таблицы нет в БД. (Изучить и
   использовать для проверки существования метод <b>Connection.getMetaData()</b>)
3. Список нецензурных слов необходимо поместить в файл, а затем, при запуске
   приложения, переместить данные в БД. При каждом новом запуске необходимо
   очищать таблицу в БД и записывать данные из файла снова.
4. При обработке необходимо делать запрос в БД для проверки нахождения слова
   в списке.
5. Приложение должно быть написано с использованием Spring Framework,
   должны быть определены и реализованы необходимые компоненты. 
6. Для проверки можно использовать RabbitMQ management console для отправки
   сообщений в очередь input.
7. Для сборки проекта необходимо использовать Maven.
8. DataSource должен создаваться со следующими параметрами подключения.  

`   PGSimpleDataSource dataSource = new PGSimpleDataSource(); `  
`   dataSource.setServerName("localhost"); `  
`   dataSource.setPortNumber(5432); `  
`   dataSource.setDatabaseName("postgres"); `  
`   dataSource.setUser("postgres"); `  
`   dataSource.setPassword("postgres"); `

